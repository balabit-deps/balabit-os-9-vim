From 4d97a565ae8be0d4debba04ebd2ac3e75a0c8010 Mon Sep 17 00:00:00 2001
From: Bram Moolenaar <Bram@vim.org>
Date: Sat, 28 May 2022 14:25:35 +0100
Subject: [PATCH] patch 8.2.5037: cursor position may be invalid after "0;"
 range

Problem:    Cursor position may be invalid after "0;" range.
Solution:   Check the cursor position when it was set by ";" in the range.
---
 src/ex_docmd.c             | 24 +++++++++++++++++-------
 src/testdir/test_excmd.vim |  8 ++++++++
 src/version.c              |  2 ++
 3 files changed, 27 insertions(+), 7 deletions(-)

--- vim-8.2.3995.orig/src/ex_docmd.c
+++ vim-8.2.3995/src/ex_docmd.c
@@ -3223,6 +3223,8 @@ parse_cmd_address(exarg_T *eap, char **e
 {
     int		address_count = 1;
     linenr_T	lnum;
+    int		need_check_cursor = FALSE;
+    int		ret = FAIL;
 
     // Repeat for all ',' or ';' separated addresses.
     for (;;)
@@ -3233,7 +3235,7 @@ parse_cmd_address(exarg_T *eap, char **e
 	lnum = get_address(eap, &eap->cmd, eap->addr_type, eap->skip, silent,
 					eap->addr_count == 0, address_count++);
 	if (eap->cmd == NULL)	// error detected
-	    return FAIL;
+	    goto theend;
 	if (lnum == MAXLNUM)
 	{
 	    if (*eap->cmd == '%')   // '%' - all lines
@@ -3278,14 +3280,14 @@ parse_cmd_address(exarg_T *eap, char **e
 			    // there is no Vim command which uses '%' and
 			    // ADDR_WINDOWS or ADDR_TABS
 			    *errormsg = _(e_invalid_range);
-			    return FAIL;
+			    goto theend;
 			}
 			break;
 		    case ADDR_TABS_RELATIVE:
 		    case ADDR_UNSIGNED:
 		    case ADDR_QUICKFIX:
 			*errormsg = _(e_invalid_range);
-			return FAIL;
+			goto theend;
 		    case ADDR_ARGUMENTS:
 			if (ARGCOUNT == 0)
 			    eap->line1 = eap->line2 = 0;
@@ -3317,7 +3319,7 @@ parse_cmd_address(exarg_T *eap, char **e
 		if (eap->addr_type != ADDR_LINES)
 		{
 		    *errormsg = _(e_invalid_range);
-		    return FAIL;
+		    goto theend;
 		}
 
 		++eap->cmd;
@@ -3325,11 +3327,11 @@ parse_cmd_address(exarg_T *eap, char **e
 		{
 		    fp = getmark('<', FALSE);
 		    if (check_mark(fp) == FAIL)
-			return FAIL;
+			goto theend;
 		    eap->line1 = fp->lnum;
 		    fp = getmark('>', FALSE);
 		    if (check_mark(fp) == FAIL)
-			return FAIL;
+			goto theend;
 		    eap->line2 = fp->lnum;
 		    ++eap->addr_count;
 		}
@@ -3344,10 +3346,13 @@ parse_cmd_address(exarg_T *eap, char **e
 	    if (!eap->skip)
 	    {
 		curwin->w_cursor.lnum = eap->line2;
+
 		// Don't leave the cursor on an illegal line or column, but do
 		// accept zero as address, so 0;/PATTERN/ works correctly.
+		// Check the cursor position before returning.
 		if (eap->line2 > 0)
 		    check_cursor();
+		need_check_cursor = TRUE;
 	    }
 	}
 	else if (*eap->cmd != ',')
@@ -3363,7 +3368,12 @@ parse_cmd_address(exarg_T *eap, char **e
 	if (lnum == MAXLNUM)
 	    eap->addr_count = 0;
     }
-    return OK;
+    ret = OK;
+
+theend:
+    if (need_check_cursor)
+	check_cursor();
+    return ret;
 }
 
 /*
--- vim-8.2.3995.orig/src/testdir/test_excmd.vim
+++ vim-8.2.3995/src/testdir/test_excmd.vim
@@ -710,5 +710,13 @@ func Test_address_line_overflow()
   bwipe!
 endfunc
 
+" This was leaving the cursor in line zero
+func Test_using_zero_in_range()
+  new
+  norm o00
+  silent!  0;s/\%')
+  bwipe!
+endfunc
+
 
 " vim: shiftwidth=2 sts=2 expandtab
