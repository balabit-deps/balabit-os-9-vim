From 7ac5023a5f1a37baafbe1043645f97ba3443d9f6 Mon Sep 17 00:00:00 2001
From: Bram Moolenaar <Bram@vim.org>
Date: Tue, 7 Mar 2023 21:05:04 +0000
Subject: [PATCH] patch 9.0.1392: using NULL pointer with nested :open command

Problem:    Using NULL pointer with nested :open command.
Solution:   Check that ccline.cmdbuff is not NULL.
---
 src/getchar.c                | 17 ++++++++++-------
 src/testdir/term_util.vim    |  5 +++++
 src/testdir/test_ex_mode.vim | 22 ++++++++++++++++++++++
 src/version.c                |  2 ++
 4 files changed, 39 insertions(+), 7 deletions(-)

--- vim-8.2.3995.orig/src/getchar.c
+++ vim-8.2.3995/src/getchar.c
@@ -2941,7 +2941,7 @@ vungetc(int c)
     static int
 vgetorpeek(int advance)
 {
-    int		c, c1;
+    int		c;
     int		timedout = FALSE;	// waited for more than 1 second
 					// for mapping to complete
     int		mapdepth = 0;		// check for recursive mapping
@@ -3307,7 +3307,7 @@ vgetorpeek(int advance)
 #ifdef FEAT_CMDL_INFO
 		showcmd_idx = 0;
 #endif
-		c1 = 0;
+		int showing_partial = FALSE;
 		if (typebuf.tb_len > 0 && advance && !exmode_active)
 		{
 		    if (((State & (NORMAL | INSERT)) || State == LANGMAP)
@@ -3321,7 +3321,7 @@ vgetorpeek(int advance)
 			    edit_putchar(typebuf.tb_buf[typebuf.tb_off
 						+ typebuf.tb_len - 1], FALSE);
 			    setcursor(); // put cursor back where it belongs
-			    c1 = 1;
+			    showing_partial = TRUE;
 			}
 #ifdef FEAT_CMDL_INFO
 			// need to use the col and row from above here
@@ -3342,6 +3342,7 @@ vgetorpeek(int advance)
 
 		    // this looks nice when typing a dead character map
 		    if ((State & CMDLINE)
+			    && get_cmdline_info()->cmdbuff != NULL
 #if defined(FEAT_CRYPT) || defined(FEAT_EVAL)
 			    && cmdline_star == 0
 #endif
@@ -3350,7 +3351,7 @@ vgetorpeek(int advance)
 		    {
 			putcmdline(typebuf.tb_buf[typebuf.tb_off
 						+ typebuf.tb_len - 1], FALSE);
-			c1 = 1;
+			showing_partial = TRUE;
 		    }
 		}
 
@@ -3386,11 +3387,12 @@ vgetorpeek(int advance)
 		if (showcmd_idx != 0)
 		    pop_showcmd();
 #endif
-		if (c1 == 1)
+		if (showing_partial)
 		{
 		    if (State & INSERT)
 			edit_unputchar();
-		    if (State & CMDLINE)
+		    if ((State & CMDLINE)
+					&& get_cmdline_info()->cmdbuff != NULL)
 			unputcmdline();
 		    else
 			setcursor();	// put cursor back where it belongs
--- vim-8.2.3995.orig/src/testdir/term_util.vim
+++ vim-8.2.3995/src/testdir/term_util.vim
@@ -54,6 +54,7 @@ endfunc
 " "cols" - width of the terminal window (max. 78)
 " "statusoff" - number of lines the status is offset from default
 " "wait_for_ruler" - if zero then don't wait for ruler to show
+" "no_clean" - if non-zero then remove "--clean" from the command
 func RunVimInTerminal(arguments, options)
   " If Vim doesn't exit a swap file remains, causing other tests to fail.
   " Remove it here.
@@ -90,6 +91,10 @@ func RunVimInTerminal(arguments, options
 
   let cmd = GetVimCommandCleanTerm() .. reset_u7 .. a:arguments
 
+  if get(a:options, 'no_clean', 0)
+    let cmd = substitute(cmd, '--clean', '', '')
+  endif
+
   let options = #{curwin: 1}
   if &termwinsize == ''
     let options.term_rows = rows
--- vim-8.2.3995.orig/src/testdir/test_ex_mode.vim
+++ vim-8.2.3995/src/testdir/test_ex_mode.vim
@@ -134,6 +134,28 @@ func Test_open_command_flush_line()
   bwipe!
 endfunc
 
+" FIXME: this doesn't fail without the fix but hangs
+func Skip_Test_open_command_state()
+  " Tricky script that failed because State was not set properly
+  let lines =<< trim END
+      !ls 
+      0scìi
+      so! Xsourced
+      set t_û0=0
+      v/-/o
+  END
+  call writefile(lines, 'XopenScript', '')
+
+  let sourced = ["!f\u0083\x02\<Esc>z=0"]
+  call writefile(sourced, 'Xsourced', 'b')
+
+  CheckRunVimInTerminal
+  let buf = RunVimInTerminal('-u NONE -i NONE -n -m -X -Z -e -s -S XopenScript -c qa!', #{rows: 6, wait_for_ruler: 0, no_clean: 1})
+  sleep 3
+
+  call StopVimInTerminal(buf)
+endfunc
+
 " Test for :g/pat/visual to run vi commands in Ex mode
 " This used to hang Vim before 8.2.0274.
 func Test_Ex_global()
