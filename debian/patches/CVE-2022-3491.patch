From 3558afe9e9e904cabb8475392d859f2d2fc21041 Mon Sep 17 00:00:00 2001
From: Bram Moolenaar <Bram@vim.org>
Date: Thu, 13 Oct 2022 16:12:57 +0100
Subject: [PATCH] patch 9.0.0742: reading past end of the line when compiling a
 function

Problem:    Reading past end of the line when compiling a function with
            errors.
Solution:   Do not return an invalid pointer.  Fix skipping redirection.
---
 src/testdir/test_vim9_func.vim   | 27 ++++++++++++++
 src/testdir/test_vim9_script.vim | 55 ++++++++++++++++++++++++++--
 src/version.c                    |  2 ++
 src/vim9cmds.c                   | 62 ++++++++++++++++++--------------
 src/vim9compile.c                | 23 +++++++++---
 5 files changed, 136 insertions(+), 33 deletions(-)

--- vim-8.2.3995.orig/src/vim9cmds.c
+++ vim-8.2.3995/src/vim9cmds.c
@@ -2086,34 +2086,37 @@ compile_redir(char_u *line, exarg_T *eap
     {
 	if (STRNCMP(arg, "END", 3) == 0)
 	{
-	    if (lhs->lhs_append)
+	    if (cctx->ctx_skip != SKIP_YES)
 	    {
-		// First load the current variable value.
-		if (compile_load_lhs_with_index(lhs, lhs->lhs_whole,
-								 cctx) == FAIL)
-		    return NULL;
-	    }
-
-	    // Gets the redirected text and put it on the stack, then store it
-	    // in the variable.
-	    generate_instr_type(cctx, ISN_REDIREND, &t_string);
-
-	    if (lhs->lhs_append)
-		generate_instr_drop(cctx, ISN_CONCAT, 1);
-
-	    if (lhs->lhs_has_index)
-	    {
-		// Use the info in "lhs" to store the value at the index in the
-		// list or dict.
-		if (compile_assign_unlet(lhs->lhs_whole, lhs, TRUE,
+		if (lhs->lhs_append)
+		{
+		    // First load the current variable value.
+		    if (compile_load_lhs_with_index(lhs, lhs->lhs_whole,
+								cctx) == FAIL)
+			return NULL;
+		}
+	
+		// Gets the redirected text and put it on the stack, then store it
+		// in the variable.
+		generate_instr_type(cctx, ISN_REDIREND, &t_string);
+
+		if (lhs->lhs_append)
+		    generate_instr_drop(cctx, ISN_CONCAT, 1);
+
+		if (lhs->lhs_has_index)
+		{
+		    // Use the info in "lhs" to store the value at the index in the
+		    // list or dict.
+		    if (compile_assign_unlet(lhs->lhs_whole, lhs, TRUE,
 						      &t_string, cctx) == FAIL)
+			return NULL;
+		}
+		else if (generate_store_lhs(cctx, lhs, -1, FALSE) == FAIL)
 		    return NULL;
-	    }
-	    else if (generate_store_lhs(cctx, lhs, -1, FALSE) == FAIL)
-		return NULL;
 
-	    VIM_CLEAR(lhs->lhs_name);
-	    VIM_CLEAR(lhs->lhs_whole);
+		VIM_CLEAR(lhs->lhs_name);
+		VIM_CLEAR(lhs->lhs_whole);
+	    }
 	    return arg + 3;
 	}
 	emsg(_(e_cannot_nest_redir));
@@ -2139,13 +2142,20 @@ compile_redir(char_u *line, exarg_T *eap
 	if (need_type(&t_string, lhs->lhs_member_type,
 					    -1, 0, cctx, FALSE, FALSE) == FAIL)
 	    return NULL;
-	generate_instr(cctx, ISN_REDIRSTART);
-	lhs->lhs_append = append;
-	if (lhs->lhs_has_index)
+	if (cctx->ctx_skip == SKIP_YES)
+	{
+	    VIM_CLEAR(lhs->lhs_name);
+	}
+	else
 	{
-	    lhs->lhs_whole = vim_strnsave(arg, lhs->lhs_varlen_total);
-	    if (lhs->lhs_whole == NULL)
-		return NULL;
+	    generate_instr(cctx, ISN_REDIRSTART);
+	    lhs->lhs_append = append;
+	    if (lhs->lhs_has_index)
+	    {
+		lhs->lhs_whole = vim_strnsave(arg, lhs->lhs_varlen_total);
+		if (lhs->lhs_whole == NULL)
+		    return NULL;
+	    }
 	}
 
 	return arg + lhs->lhs_varlen_total;
--- vim-8.2.3995.orig/src/vim9compile.c
+++ vim-8.2.3995/src/vim9compile.c
@@ -1084,6 +1084,19 @@ vim9_declare_error(char_u *name)
 }
 
 /*
+ * Return TRUE if "name" is a valid register to use.
+ * Return FALSE and give an error message if not.
+ */
+    static int
+valid_dest_reg(int name)
+{
+    if ((name == '@' || valid_yank_reg(name, FALSE)) && name != '.')
+	return TRUE;
+    emsg_invreg(name);
+    return FAIL;
+}
+
+/*
  * For one assignment figure out the type of destination.  Return it in "dest".
  * When not recognized "dest" is not set.
  * For an option "option_scope" is set.
@@ -1164,12 +1177,8 @@ get_var_dest(
     }
     else if (*name == '@')
     {
-	if (name[1] != '@'
-			&& (!valid_yank_reg(name[1], FALSE) || name[1] == '.'))
-	{
-	    emsg_invreg(name[1]);
+	if (!valid_dest_reg(name[1]))
 	    return FAIL;
-	}
 	*dest = dest_reg;
 	*type = name[1] == '#' ? &t_number_or_string : &t_string;
     }
@@ -1244,7 +1253,11 @@ compile_lhs(
     // "var_end" is the end of the variable/option/etc. name.
     lhs->lhs_dest_end = skip_var_one(var_start, FALSE);
     if (*var_start == '@')
+    {
+	if (!valid_dest_reg(var_start[1]))
+	    return FAIL;
 	var_end = var_start + 2;
+    }
     else
     {
 	// skip over the leading "&", "&l:", "&g:" and "$"
