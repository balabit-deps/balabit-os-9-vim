[Ubuntu note: CleanUpTestAuGroup() is not present in test_autocmd.vim
defer is not present, replace with call in test_autocmd.vim
--Hlib Korzhynskyy]

Backport of:

From 51b62387be93c65fa56bbabe1c3c1ea5df187641 Mon Sep 17 00:00:00 2001
From: Christian Brabandt <cb@256bit.org>
Date: Sun, 6 Oct 2024 17:31:10 +0200
Subject: [PATCH] patch 9.1.0764: [security]: use-after-free when closing a
 buffer

Problem:  [security]: use-after-free when closing a buffer
Solution: When splitting the window and editing a new buffer,
          check whether the newly to be edited buffer has been marked
          for deletion and abort in this case

Github Advisory:
https://github.com/vim/vim/security/advisories/GHSA-rj48-v4mq-j4vg

Signed-off-by: Christian Brabandt <cb@256bit.org>
---
 src/buffer.c                 |  6 ++++++
 src/ex_cmds.c                | 12 ++++++++++++
 src/proto/buffer.pro         |  1 +
 src/testdir/test_autocmd.vim | 19 +++++++++++++++++++
 src/version.c                |  2 ++
 5 files changed, 40 insertions(+)

Index: vim-8.2.3995/src/buffer.c
===================================================================
--- vim-8.2.3995.orig/src/buffer.c
+++ vim-8.2.3995/src/buffer.c
@@ -469,6 +469,12 @@ can_unload_buffer(buf_T *buf)
     return can_unload;
 }
 
+    int
+buf_locked(buf_T *buf)
+{
+    return buf->b_locked || buf->b_locked_split;
+}
+
 /*
  * Close the link to a buffer.
  * "action" is used when there is no longer a window for the buffer.
Index: vim-8.2.3995/src/ex_cmds.c
===================================================================
--- vim-8.2.3995.orig/src/ex_cmds.c
+++ vim-8.2.3995/src/ex_cmds.c
@@ -2700,6 +2700,18 @@ do_ecmd(
 	}
 	if (buf == NULL)
 	    goto theend;
+	// autocommands try to edit a file that is goind to be removed,
+	// abort
+	if (buf_locked(buf))
+	{
+	    // window was split, but not editing the new buffer,
+	    // reset b_nwindows again
+	    if (oldwin == NULL
+		    && curwin->w_buffer != NULL
+		    && curwin->w_buffer->b_nwindows > 1)
+		--curwin->w_buffer->b_nwindows;
+	    goto theend;
+	}
 	if (curwin->w_alt_fnum == buf->b_fnum && prev_alt_fnum != 0)
 	    // reusing the buffer, keep the old alternate file
 	    curwin->w_alt_fnum = prev_alt_fnum;
Index: vim-8.2.3995/src/proto/buffer.pro
===================================================================
--- vim-8.2.3995.orig/src/proto/buffer.pro
+++ vim-8.2.3995/src/proto/buffer.pro
@@ -70,4 +70,5 @@ char_u *buf_get_fname(buf_T *buf);
 void set_buflisted(int on);
 int buf_contents_changed(buf_T *buf);
 void wipe_buffer(buf_T *buf, int aucmd);
+int buf_locked(buf_T *buf);
 /* vim: set ft=c : */
Index: vim-8.2.3995/src/testdir/test_autocmd.vim
===================================================================
--- vim-8.2.3995.orig/src/testdir/test_autocmd.vim
+++ vim-8.2.3995/src/testdir/test_autocmd.vim
@@ -2960,4 +2960,22 @@ func Test_Changed_ChangedI()
   bw!
 endfunc
 
+" This was using freed memory
+func Test_autocmd_BufWinLeave_with_vsp()
+  new
+  let fname = 'XXXBufWinLeaveUAF.txt'
+  let dummy = 'XXXDummy.txt'
+  call writefile([], fname)
+  call writefile([], dummy)
+  exe "e " fname
+  vsp
+  augroup testing
+    exe "au BufWinLeave " .. fname .. " :e " dummy .. "| vsp " .. fname
+  augroup END
+  bw
+  exe "bw! " .. dummy
+  call delete(fname)
+  call delete(dummy)
+endfunc
+
 " vim: shiftwidth=2 sts=2 expandtab
