[Ubuntu note: removed changes made to version.c because they were not needed
 to fix the vulnerability. A slight modification had to be made to changes
 applied to file quickfix.c. Since this version of the code does not include
 changes made by commit 6574577cac (in which the second NULL in
 'vim_regexec_multi' call is removed from the call), the patch had to be
 adjusted in order to apply cleanly. The choice to simply modify the changes
 made by this patch instead of applying commit 6574577cac and then applying
 this patch comes from the fact that changes made by commit 6574577cac are
 simply functionality changes in order to calculate timeouts more efficiently
 (they are not security related changes, regression fixing changes or changes
 required in order to get the changes in this file to completely work - such
 as a change that would include a new variable that could be later used here).
 It also is a commit that alters many files, and adding it instead of simply
 adjusting the changes made here in this file might increase the risk of
 introducing regressions. Finally, changes made to quickfix.c in HUNK #2 are
 merely aesthetic, and could be removed entirely. 
 -- Camila Camargo de Matos <camila.camargodematos@canonical.com>]

Origin: backport, https://github.com/vim/vim/commit/caf642c25de526229264cab9425e7c9979f3509b

From caf642c25de526229264cab9425e7c9979f3509b Mon Sep 17 00:00:00 2001
From: Bram Moolenaar <Bram@vim.org>
Date: Sat, 29 Apr 2023 21:38:04 +0100
Subject: [PATCH] patch 9.0.1499: using uninitialized memory with fuzzy
 matching

Problem:    Using uninitialized memory with fuzzy matching.
Solution:   Initialize the arrays used to store match positions.
---
 src/quickfix.c                  |  5 ++++-
 src/search.c                    | 17 +++++++----------
 src/testdir/test_matchfuzzy.vim | 27 +++++++++++++++++++++++++++
 src/version.c                   |  2 ++
 4 files changed, 40 insertions(+), 11 deletions(-)

Index: vim-8.2.3995/src/quickfix.c
===================================================================
--- vim-8.2.3995.orig/src/quickfix.c
+++ vim-8.2.3995/src/quickfix.c
@@ -5936,6 +5936,8 @@ vgr_match_buflines(
     long	lnum;
     colnr_T	col;
     int		pat_len = (int)STRLEN(spat);
+    if (pat_len > MAX_FUZZY_MATCHES)
+	pat_len = MAX_FUZZY_MATCHES;
 
     for (lnum = 1; lnum <= buf->b_ml.ml_line_count && *tomatch > 0; ++lnum)
     {
@@ -5944,7 +5946,7 @@ vgr_match_buflines(
 	{
 	    // Regular expression match
 	    while (vim_regexec_multi(regmatch, curwin, buf, lnum,
-			col, NULL, NULL) > 0)
+								col, NULL, NULL) > 0)
 	    {
 		// Pass the buffer number so that it gets used even for a
 		// dummy buffer, unless duplicate_name is set, then the
@@ -5990,6 +5992,7 @@ vgr_match_buflines(
 	    int_u   sz = ARRAY_LENGTH(matches);
 
 	    // Fuzzy string match
+	    CLEAR_FIELD(matches);
 	    while (fuzzy_match(str + col, spat, FALSE, &score, matches, sz) > 0)
 	    {
 		// Pass the buffer number so that it gets used even for a
Index: vim-8.2.3995/src/search.c
===================================================================
--- vim-8.2.3995.orig/src/search.c
+++ vim-8.2.3995/src/search.c
@@ -4436,14 +4436,14 @@ fuzzy_match_recursive(
 	// Found match
 	if (vim_tolower(c1) == vim_tolower(c2))
 	{
-	    int_u	recursiveMatches[MAX_FUZZY_MATCHES];
-	    int		recursiveScore = 0;
-	    char_u	*next_char;
-
 	    // Supplied matches buffer was too short
 	    if (nextMatch >= maxMatches)
 		return 0;
 
+	    int		recursiveScore = 0;
+	    int_u	recursiveMatches[MAX_FUZZY_MATCHES];
+	    CLEAR_FIELD(recursiveMatches);
+
 	    // "Copy-on-Write" srcMatches into matches
 	    if (first_match && srcMatches)
 	    {
@@ -4452,10 +4452,7 @@ fuzzy_match_recursive(
 	    }
 
 	    // Recursive call that "skips" this match
-	    if (has_mbyte)
-		next_char = str + (*mb_ptr2len)(str);
-	    else
-		next_char = str + 1;
+	    char_u *next_char = str + (has_mbyte ? (*mb_ptr2len)(str) : 1);
 	    if (fuzzy_match_recursive(fuzpat, next_char, strIdx + 1,
 			&recursiveScore, strBegin, strLen, matches,
 			recursiveMatches,
@@ -4520,8 +4517,8 @@ fuzzy_match_recursive(
  * Uses char_u for match indices. Therefore patterns are limited to
  * MAX_FUZZY_MATCHES characters.
  *
- * Returns TRUE if 'pat_arg' matches 'str'. Also returns the match score in
- * 'outScore' and the matching character positions in 'matches'.
+ * Returns TRUE if "pat_arg" matches "str". Also returns the match score in
+ * "outScore" and the matching character positions in "matches".
  */
     int
 fuzzy_match(
Index: vim-8.2.3995/src/testdir/test_matchfuzzy.vim
===================================================================
--- vim-8.2.3995.orig/src/testdir/test_matchfuzzy.vim
+++ vim-8.2.3995/src/testdir/test_matchfuzzy.vim
@@ -2,6 +2,7 @@
 
 source shared.vim
 source check.vim
+source term_util.vim
 
 " Test for matchfuzzy()
 func Test_matchfuzzy()
@@ -230,4 +231,30 @@ func Test_matchfuzzypos_mbyte()
   call assert_equal([['xффйд'], [[2, 3, 4]], [168]], matchfuzzypos(['xффйд'], 'фйд'))
 endfunc
 
+" This was using uninitialized memory
+func Test_matchfuzzy_initialized()
+  CheckRunVimInTerminal
+
+  " This can take a very long time (esp. when using valgrind).  Run in a
+  " separate Vim instance and kill it after two seconds.  We only check for
+  " memory errors.
+  let lines =<< trim END
+      lvimgrep [ss [fg*
+  END
+  call writefile(lines, 'XTest_matchfuzzy', 'D')
+
+  let buf = RunVimInTerminal('-u NONE -X -Z', {})
+  call term_sendkeys(buf, ":source XTest_matchfuzzy\n")
+  call TermWait(buf, 2000)
+
+  let job = term_getjob(buf)
+  if job_status(job) == "run"
+    call job_stop(job, "int")
+    call TermWait(buf, 50)
+  endif
+
+  " clean up
+  call StopVimInTerminal(buf)
+endfunc
+
 " vim: shiftwidth=2 sts=2 expandtab
